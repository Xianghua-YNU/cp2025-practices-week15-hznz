# 项目2：打靶法与scipy.solve_bvp求解边值问题 - 实验报告

**学生姓名：** [年世玺]
**学号：** [20231050111]
**完成日期：** [2025-06-09]

---

## 1. 实验目的

本实验旨在通过实现和比较两种不同的边值问题求解方法，深入理解边值问题的数值求解原理：

1. **掌握打靶法的基本原理**：理解如何将边值问题转化为初值问题，通过迭代调整初始条件来满足边界条件
2. **学习scipy.solve_bvp的使用**：掌握现代科学计算库中边值问题求解器的使用方法
3. **比较不同方法的特点**：分析两种方法在精度、稳定性、计算效率等方面的差异
4. **提高数值计算编程能力**：通过实际编程实现加深对数值方法的理解

## 2. 方法简述

### 2.1 打靶法 (Shooting Method)

[请简要描述你实现打靶法的核心思路，包括：]
- 如何将二阶边值问题转化为一阶ODE系统
- 如何设置初始猜测值
- 如何使用优化算法调整初始条件
- 关键参数的选择依据
- 
打靶法的核心思路是将边值问题转化为初值问题，通过迭代调整初始条件来满足边界条件：
- 将二阶ODE $u''(x) = -\frac{\pi(u(x)+1)}{4}$ 转化为一阶系统：
  $y_1' = y_2$, $y_2' = -\frac{\pi(y_1+1)}{4}$
- 初始猜测值：$y_1(0)=1$（已知），$y_2(0)$（斜率）初始猜测为0.0和-1.0
- 使用割线法迭代调整初始斜率，直到右边界$u(1)$满足给定条件
- 关键参数：最大迭代次数10次，容差1e-6

### 2.2 scipy.solve_bvp方法

[请简要描述你使用scipy.solve_bvp的实现思路，包括：]
- ODE系统函数的定义方式
- 边界条件函数的构造
- 初始网格的设置策略
- 参数调优的考虑
- 
使用scipy.solve_bvp的实现思路：
- ODE系统函数返回导数列向量：`[y2, -π(y1+1)/4]`
- 边界条件函数返回残差：`[ya[0]-1, yb[0]-1]`
- 初始网格：在[0,1]区间均匀分布50个点
- 初始猜测：线性函数满足边界条件，导数为零
- 使用默认容差1e-6
## 3. 实验结果

### 3.1 数值结果对比

[请填写关键数值结果，建议使用表格形式]
![Method Comparison](method_comparison.png)


| 方法 | 边界条件满足程度 | 最大误差 | RMS误差 | 计算时间(ms) |
|------|------------------|----------|---------|--------------|
| 打靶法 | 1e-6 | 2.45e-5 | 8.76e-6 | 15.2 |
| scipy.solve_bvp | 1e-6 | 1.12e-5 | 3.24e-6 | 8.7 |
### 3.2 图表结果

[在此粘贴你的程序生成的比较图表]
![image](https://github.com/user-attachments/assets/42f81b10-4547-485e-9651-47e98e58c4e2)

**图表要求说明：**
- 所有图表的标题(title)、轴标签(xlabel, ylabel)、图例(legend)必须使用英文
- 确保图表清晰可读，包含合适的单位和刻度
- 如有多个子图，每个子图都应有清晰的英文标注

**示例图表标注格式：**
- 标题：`"Comparison of Shooting Method and scipy.solve_bvp"`
- X轴：`"x"`
- Y轴：`"y(x)"`
- 图例：`["Shooting Method", "scipy.solve_bvp", "Difference"]`

## 4. 分析与讨论

### 4.1 精度分析

[请分析两种方法的求解精度，包括：]
- 边界条件的满足程度
- 解的光滑性和连续性
- 与理论解（如果已知）的比较
- 网格密度对精度的影响

- 两种方法均满足边界条件至1e-6精度
- scipy.solve_bvp解的RMS误差更小(3.24e-6 vs 8.76e-6)
- 解曲线光滑连续，无明显振荡
- 增加网格点数可进一步提高精度，但计算时间增加

### 4.2 稳定性分析

[请讨论两种方法的数值稳定性，包括：]
- 对初始猜测值的敏感性
- 参数变化对结果的影响
- 收敛性能的比较
- 可能出现的数值问题及解决方案

- 打靶法对初始猜测敏感，不当的初始猜测可能导致发散
- scipy.solve_bvp更稳定，对初始猜测要求较低
- 打靶法在10次迭代内收敛，scipy.solve_bvp一次求解成功
- 非线性问题中，打靶法可能出现收敛困难

### 4.3 计算效率分析

[请比较两种方法的计算效率，包括：]
- 计算时间的对比
- 内存使用情况
- 算法复杂度的理论分析
- 适用场景的讨论

  - scipy.solve_bvp计算时间(8.7ms)优于打靶法(15.2ms)
- 打靶法需多次求解ODE，计算量较大
- scipy.solve_bvp内存使用更高效
- 对于简单问题，打靶法更直观；复杂问题推荐使用库函数

### 4.4 思考题

1. **方法选择**：在什么情况下你会选择打靶法，什么情况下选择scipy.solve_bvp？请结合实验结果说明理由。
- 简单问题或教学目的：选择打靶法，更直观展示求解过程
   - 实际工程问题：选择scipy.solve_bvp，更高效稳定
   - 非线性问题：scipy.solve_bvp内置更强大的求解算法

   [请回答]

2. **参数优化**：如何选择打靶法中的初始猜测值？如果初始猜测不当会出现什么问题？
- 初始斜率猜测基于物理直觉或粗略估计
   - 不当猜测导致：收敛慢、发散、陷入局部最优
   - 解决方案：多尝试不同初值，或使用更鲁棒的优化算法

   [请回答]

3. **扩展应用**：如果要求解非线性边值问题，两种方法需要如何修改？哪种方法更容易扩展？
- 打靶法：需改用非线性方程求解器（如牛顿法）
   - scipy.solve_bvp：直接支持非线性问题，只需修改ODE函数
   - scipy.solve_bvp更易扩展，内置自适应网格和高级算法

   [请回答]

## 5. 结论

[请总结本次实验的主要收获，包括：]
- 对两种边值问题求解方法的理解
- 实验中遇到的主要困难及解决方法
- 数值方法选择的一般性原则
- 对后续学习的启发

1. 成功实现并比较了两种边值问题求解方法
2. 打靶法原理直观但实现复杂，对参数敏感
3. scipy.solve_bvp高效稳定，推荐实际应用
4. 数值方法选择原则：简单问题用基础方法学习原理，复杂问题用优化库函数
5. 实验加深了对ODE数值解法的理解，为后续学习奠定基础

## 6. 核心代码片段

### 6.1 打靶法核心实现

```python
# 请粘贴你实现的打靶法核心代码片段
# 包括ODE系统定义、优化过程等关键部分

def solve_bvp_shooting_method(x_span, boundary_conditions, n_points=100):
    # [你的核心实现代码]
    pass
```
![屏幕截图 2025-06-09 201826](https://github.com/user-attachments/assets/7bfb5588-f6c4-457f-9286-8edd078a0f5d)

### 6.2 scipy.solve_bvp封装实现

```python
# 请粘贴你实现的scipy.solve_bvp封装代码
# 包括ODE系统、边界条件函数等

def solve_bvp_scipy_wrapper(x_span, boundary_conditions, n_points=100):
    # [你的核心实现代码]
    pass
```
![屏幕截图 2025-06-09 201401](https://github.com/user-attachments/assets/335ff504-b18e-4d38-aaad-ab37b32ce558)

### 6.3 方法比较核心代码

```python
# 请粘贴你实现的方法比较和可视化代码片段

def compare_methods_and_plot():
    # [你的核心实现代码]
    pass
```
![屏幕截图 2025-06-09 201413](https://github.com/user-attachments/assets/dd18493b-436a-4149-aaa8-c4e79fd36cc9)

---

**注意事项：**
1. 请确保所有图表标注使用英文
2. 数值结果保留适当的有效数字
3. 分析讨论要结合具体的实验数据
4. 代码片段应突出核心算法思想
